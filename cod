#include <iostream>
#include <fstream>
#include <cmath>
using namespace std;

// Structura pentru un punct in plan
struct Punct {
    double x, y;
    Punct(double x = 0, double y = 0) : x(x), y(y) {}
};

// Calculeaza determinantul pentru orientarea a trei puncte
double calculeazaDeterminant(const Punct& a, const Punct& b, const Punct& c) {
    return b.x * c.y + c.x * a.y + a.x * b.y - 
           a.y * b.x - b.y * c.x - a.x * c.y;
}

// Calculeaza determinantul pentru doua puncte fata de origine
double determinantCuOrigine(const Punct& a, const Punct& b) {
    return a.x * b.y - a.y * b.x;
}

// Determina cadranul in care se afla punctul
int determinaCadran(const Punct& p) {
    if (p.x > 0 && p.y >= 0) return 1;
    if (p.x <= 0 && p.y > 0) return 2;
    if (p.x < 0 && p.y <= 0) return 3;
    return 4;
}

// Functie de comparare pentru sortarea polara
bool compararePolara(const Punct& a, const Punct& b) {
    int cadranA = determinaCadran(a);
    int cadranB = determinaCadran(b);
    
    // Daca sunt in cadrane diferite, sorteaza dupa cadran
    if (cadranA != cadranB) {
        return cadranA < cadranB;
    }
    
    // Daca sunt coliniari cu originea, sorteaza dupa distanta
    if (determinantCuOrigine(a, b) == 0) {
        return a.y < b.y;
    }
    
    // Altfel, sorteaza in sens trigonometric
    return determinantCuOrigine(a, b) > 0;
}

// Sortare Bubble Sort pentru puncte
void sorteazaPuncte(Punct puncte[], int n) {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n - i; j++) {
            if (!compararePolara(puncte[j], puncte[j + 1])) {
                Punct temp = puncte[j];
                puncte[j] = puncte[j + 1];
                puncte[j + 1] = temp;
            }
        }
    }
}

// Cautare binara pentru a gasi pozitia punctului M in sortarea polara
int cautareBinara(Punct puncte[], int n, const Punct& m) {
    int stanga = 1;
    int dreapta = n;
    
    while (stanga <= dreapta) {
        int mijloc = stanga + (dreapta - stanga) / 2;
        
        // Verificam daca M se afla intre puncte[mijloc] si puncte[mijloc+1]
        if (compararePolara(puncte[mijloc], m) && 
            compararePolara(m, puncte[mijloc + 1])) {
            return mijloc + 1;
        } else if (compararePolara(puncte[mijloc], m)) {
            stanga = mijloc + 1;
        } else {
            dreapta = mijloc - 1;
        }
    }
    
    return 1; // Daca nu gasim, returnam prima pozitie
}

int main() {
    ifstream fisier("date.in");
    
    if (!fisier) {
        cerr << "Eroare: Nu s-a putut deschide fisierul date.in" << endl;
        return 1;
    }
    
    int n;
    Punct punctTest;
    fisier >> n >> punctTest.x >> punctTest.y;
    
    if (n < 3 || n > 100) {
        cerr << "Eroare: Numarul de puncte trebuie sa fie intre 3 si 100" << endl;
        return 1;
    }
    
    Punct puncte[102]; // +2 pentru puncte auxiliare
    Punct centruGreutate(0, 0);
    
    // Citeste punctele si calculeaza centrul de greutate
    for (int i = 1; i <= n; i++) {
        fisier >> puncte[i].x >> puncte[i].y;
        centruGreutate.x += puncte[i].x;
        centruGreutate.y += puncte[i].y;
    }
    
    fisier.close();
    
    // Calculeaza centrul de greutate
    centruGreutate.x /= n;
    centruGreutate.y /= n;
    
    // Translatie: muta toate punctele astfel incat centrul de greutate devine originea
    punctTest.x -= centruGreutate.x;
    punctTest.y -= centruGreutate.y;
    
    for (int i = 1; i <= n; i++) {
        puncte[i].x -= centruGreutate.x;
        puncte[i].y -= centruGreutate.y;
    }
    
    // Sorteaza punctele in sens trigonometric (polar)
    sorteazaPuncte(puncte, n);
    
    // Adauga puncte auxiliare pentru cazurile marginale
    puncte[0] = puncte[n];
    puncte[n + 1] = puncte[1];
    
    // Gaseste pozitia punctului M in sortarea polara
    int pozitie = cautareBinara(puncte, n, punctTest);
    
    cout << "Pozitie: " << pozitie << endl;
    
    // Determina pozitia punctului M fata de triunghiul format
    double determinant = calculeazaDeterminant(punctTest, 
                                                puncte[pozitie - 1], 
                                                puncte[pozitie]);
    
    // Retransformare in coordonate originale pentru afisare
    double x1 = puncte[pozitie - 1].x + centruGreutate.x;
    double y1 = puncte[pozitie - 1].y + centruGreutate.y;
    double x2 = puncte[pozitie].x + centruGreutate.x;
    double y2 = puncte[pozitie].y + centruGreutate.y;
    
    if (determinant > 0) {
        cout << "Punctul M apartine interiorului zonei formate cu originea, ("
             << x1 << ", " << y1 << ") si (" << x2 << ", " << y2 << ")" << endl;
    } else if (determinant < 0) {
        cout << "Punctul M apartine exteriorului zonei formate cu originea, ("
             << x1 << ", " << y1 << ") si (" << x2 << ", " << y2 << ")" << endl;
    } else {
        cout << "Punctul M apartine frontierei zonei formate cu originea, ("
             << x1 << ", " << y1 << ") si (" << x2 << ", " << y2 << ")" << endl;
    }
    
    return 0;
}
